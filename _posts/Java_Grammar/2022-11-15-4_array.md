---
title: "Java 문법 4. Array(배열)"
excerpt: "Java 배열의 이해"

categories:
  - JavaGrammar
tags:
  - [Java, Grammar]

comments: true
toc: true
toc_sticky: true

date: 2020-11-15
last_modified_at: 2020-11-15
---

## Array(배열)

> ### 1. 배열

- 같은 자료형의 변수를 하나의 묶음으로 다루는 것
- 배열은 저장된 값마다 인덱스 번호가 0부터 시작하여 설정된다
- 자바에서 배열 공간은 자유 메모리 영역인 Heap 영역에 할당되며 배열은 배열 공간의 주소를 저장한다
  - Heap영역에 할당된 배열 공간의 주소를 이용해 인덱스를 참조하는 방식으로 값을 처리한다
- 각 배열은 배열이 저장된 주소값을 가지고 있기 때문에 배열1==배열2 와 같이 동등 비교를 한다면 무조건 false를 반환하게된다  
   -> 주소값은 중복될 수 없는 고유한 값이기 때문으로 최초에 배열 선언부터 다른 주소와 겹치지 않는 주소로 할당된다

<br>

#### [ 배열 선언 ]

```java
int[ ] arr;
int arr[ ];
```

- 타입[ ] 변수이름; or 타입 변수이름[ ]; 형태로 선언한다
- 배열을 선언한다고 해서 값을 저장하는 공간이 생기지는 않는다.

<br>

#### [ 배열 생성 ]

```java
String[ ] strArr = new String[3];
```

- 배열참조변수 = new 데이터타입 [연속 할당될 변수 갯수];
- 데이터타입 [ ] 변수 = new 데이터타입 \[첨자];

- 배열을 생성할 때 배열의 길이(첨자)를 지정해 주면 해당 데이터타입의 값을 저장할 수 있는 저장공간을 길이 갯수만큼 연속 할당한다
- 배열의 선언과 생성은 한 줄로 가능하다

- 배열 생성 시 각 인덱스에 따로 값을 넣어주지 않았더라도 해당 인덱스는 빈값이 되지 않는다  
  -> Heap 영역에는 빈공간을 할당할 수 없기 때문  
  -> JVM에서 각 인덱스에 자동으로 주소값을 할당하여 생성해준다

<br>

#### [ 배열의 초기화 ]

```java
String strArr[] = { "Apple", "Banana", "Orange" };
```

- 데이터타입[ ] 배열참조변수 = {값1, 값2, 값3, … };
- 데이터타입[ ] 배열참조변수 = new 데이터타입[ ] {값1, 값2, 값3, ….};

- 배열 공간 할당과 동시에 초기값을 기록하는 것을 말한다
- 배열 초기화시에는 배열의 길이를 따로 지정하지 않고 초기화에 사용되는 값의 개수가 자동 배열의 길이로 처리된다
- 자바에서는 배열 공간의 초기화를 따로 지정하지 않아도 자동 초기화 처리가 되도록 각 자료형별 기본값이 준비되어 있다  
   -> `boolean : false`, `char : ‘\u0000’`, `정수형 : 0`, `실수형 : 0.0`, `참조형 : null`

<br>

#### [ 배열의 인덱스 ]

- 생성된 배열 공간의 각 저장공간을 요소(element) 라고 부른다
- `배열이름 [인덱스]` 형식으로 요소에 접근할 수 있다
- 배열의 저장공간의 개수를 배열의 길이(length)라고 한다  
   -> `배열이름.length()`를 사용하여 길이를 구할 수 있다
- 인덱스는 0 부터 시작해서 배열의 길이 (-)1 까지 지정된다

<br>

#### [ 배열의 복사 ]

```java
String originArr[ ] = { "Apple", "Banana", "Orange" };
String destArr[ ]; // 배열의 주소 복사용 배열레퍼런스 선언

destArr = originArr; // 주소 복사
```

- 얕은 복사(Shallow Copy)
  - 참조하는 배열공간의 주소를 다른 참조변수에 복사하는 것  
    -> 객체의 주소값만 가져와 참조형 변수에 저장하고 하나의 객체를 두 변수가 참조하는 것이다
  - 이경우 원조 배열안의 값이 변경되면 복사한 배열로 불러오는 값도 같이 변경되어 출력된다  
    -> 복사한 배열 안에 원조 배열의 실제 값이 들어간 것이 아니라 값이 저장되어있는 주소만 복사된 것이기 때문

```java
String originArr[ ] = { "Apple", "Banana", "Orange" };
String destArr[ ] = new String [originArr.length];

//1번
for(int i= 0; i< originArr.length; i++){
    destArr[i] = originArr[i];
}

//2번
System.arrayCopy(originArr, 0, destArr, 0, originArr.length);
```

- 깊은 복사(Deep Copy)
  - 배열공간의 값들을 다른 배열공간에 하나씩 복사하는 것  
    -> 새로운 배열 객체를 생성하여 기존 배열의 데이터를 복사하는 것이다
  - 1번
    - for문을 이용하여 각 인덱스별 데이터를 하나씩 복사해 넣어주는 방식
  - 2번
    - java.lang.System 클래스의 arrayCopy() 메소드를 사용하는 방식
    - arraycopy(src, srcPos, dest, destPos, length)를 사용하여 데이터를 복사한다  
       -> src : 원본 배열, src : 원본 배열 시작 인덱스, dest : 복사할 배열, destPos : 복사할 배열 시작 인덱스, length : 복사할 길이
    - for문을 이용한 복사보다 arrayCopy() 함수를 이용한 방법이 더 효율적이다

<br>

### 2. 다차원 배열

- 배열 안에 다른 배열이 존재하는 것
- 2차원 배열은 할당된 공간마다 인덱스 번호 두개를 부여한다 (앞번호는 행, 뒷번호는 열 \[행][열])

<br>

#### [ 2차원 배열의 선언 ]

```java
int score[ ][ ];
int[ ] score2[ ];
int[ ][ ] score3;
```

- 데이터타입 배열참조변수[ ][ ];
- 데이터타입[ ] 배열참조변수[ ];
- 데이터타입[ ][ ] 배열참조변수;

<br>

#### [ 2차원 배열의 생성 ]

```java
score = new int[5][5]; //정변배열
score2 = new int[5][ ]; //가변배열, 행만 선언
score3[5] = new int[7]; //행에 대한 열 선언
```

- 정변배열 : 배열참조변수 = new 데이터타입\[행길이][열길이];
- 가변배열(행만 선언) : 배열참조변수 = new 데이터타입\[행길이][ ];
- 행에 대한 열 선언 : 배열참조변수\[행인덱스] = new 데이터타입\[열길이];

- 행길이 : 묶여질 1차원 배열의 개수
- 열길이 : 각 1차원 배열의 값 개수
- 정변배열 : 행길이와 열길이가 같은 경우
- 가변배열 : 행길이와 행별 열길이가 다른 경우

<br>

#### [ 2차원 배열의 초기화 ]

```java
int score[ ][ ] = { {0, 1, 3, … }, {1, 2, …}, … }
```

- 데이터타입 배열이름[ ][ ] = { {0행0열값, 0행1열값, … }, {1행0열값, 1행1열값, …}, … }
